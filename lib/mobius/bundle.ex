defmodule Mobius.Bundle do
  defmodule SaveError do
    @moduledoc """
    Exception implementation for when there is an error saving the bundle
    """

    @typedoc """
    Save error

    * `:message` - the message that is used for the exception

    ```elixir
    iex> save_error = SaveError.exception("Bad things happened")
    iex> Exception.message(save_error)
    "Error saving bundle: Bad things happened"
    ```
    """
    @type t() :: %__MODULE__{message: binary()}

    defexception [:message]

    @impl Exception
    def exception(value) do
      %__MODULE__{message: "Error saving bundle: #{inspect(value)}"}
    end
  end

  defmodule ExtractError do
    @moduledoc """
    Exception implementation for when there is an error extracting a bundle
    """

    @typedoc """
    Extract error

    * `:message` - the message that is used for the exception

    ```elixir
    iex> extract_error = ExtractError.exception({"file open", "Oh no!"})
    iex> Exception.message(extract_error)
    "Error extracting the bundle during file open because Oh no!"
    ```
    """
    @type t() :: %__MODULE__{message: binary()}

    defexception [:message]

    @impl Exception
    def exception({error_operation, error_reason}) do
      %__MODULE__{
        message:
          "Error extracting the bundle during #{error_operation} because #{inspect(error_reason)}"
      }
    end
  end

  @bundle_version 1

  @typedoc """
  The target is who the the bundle is created for

  This can be Nerves device's serial number or the name of the application using
  Mobius. This is useful for external services to identify which entity is
  sending the bundle.
  """
  @type target() :: binary()

  @typedoc """
  Meta information for a bundle

  * `:target` - the target name of the device or application using mobius
  * `:version` - the bundle version used when creating the bundle
  * `:number_of_records` - the number of records in the bundle
  """
  @type meta() :: %{
          target: target(),
          version: non_neg_integer(),
          number_of_records: non_neg_integer()
        }

  @typedoc """
  A bundle

  * `:meta` - extra info about the containing data and other pieces of
    information that might be useful a consuming service
  * `:data` - the data
  """
  @type t() :: %{
          meta: meta(),
          data: list()
        }

  @doc """
  Make a new bundle
  """
  @spec new(target(), [Mobius.record()]) :: t()
  def new(bundle_target, records) do
    meta = %{target: bundle_target, number_of_records: length(records), version: @bundle_version}
    %{meta: meta, data: records}
  end

  @typedoc """
  Options for creating a bundle

  * `:out_dir` - the output directory for the bundle, by default this is the
    `/tmp` directory
  * `:compressed` - if the bundle should use compression
  * `:verbose` - print extra information about each file added to the bundle
  * `:prefix` - a prefix to the file name generated by saving the bundle. By
    default this is the current system time in the `:native` time unit.
  """
  @type save_opt() ::
          {:out_dir, binary()} | {:prefix, binary() | integer()} | :compressed | :verbose

  @doc """
  Save a bundle to disk

  If saving the bundle works this will print the path to the created bundle.
  This is useful as often times you might want to do something with bundle
  shortly after its creation.
  """
  @spec save(t(), [save_opt()]) :: {:ok, Path.t()} | {:error, SaveError.t()}
  def save(bundle, opts \\ []) do
    data = :erlang.term_to_binary(bundle.data)
    meta = :erlang.term_to_binary(bundle.meta)
    out_dir = opts[:out_dir] || "/tmp"
    extension = get_extension(opts)
    prefix = opts[:prefix] || System.system_time()
    file = "#{prefix}_mobius_bundle.#{extension}"
    out_file = Path.join(out_dir, file)

    case :erl_tar.create(out_file, [{'meta', meta}, {'data', data}], opts) do
      :ok ->
        {:ok, out_file}

      {:error, reason} ->
        {:error, SaveError.exception(reason)}
    end
  end

  defp get_extension(opts) do
    if Enum.any?(opts, fn opt -> opt == :compressed end) do
      "tar.gz"
    else
      "tar"
    end
  end

  @typedoc """
  Options to use when extracting

  * `:time_as` - convert the system time into either DateTime or NaiveDateTime.
  * `:extract_dir` - the directory to use for bundle extraction, this is cleaned
    up after extraction.

  Converting time is useful because different time series databases expect
  different types of timestamps. If you're saving data into a time series
  database be sure to read the documentation to make sure you're providing the
  right information to your database.
  """
  @type extract_opt() :: {:time_as, module()} | {:extract_dir, Path.t()}

  @spec extract(Path.t(), [extract_opt()]) :: {:ok, t()} | {:error, ExtractError.t()}
  def extract(bundle_file, opts \\ []) do
    extract_top_dir = opts[:extract_dir] || System.tmp_dir()
    extract_dir = Path.join(extract_top_dir, get_rootname(bundle_file))

    with :ok <- File.mkdir(extract_dir),
         :ok <- :erl_tar.extract(bundle_file, [{:cwd, to_charlist(extract_dir)}, :compressed]),
         {:ok, meta} <- read_and_decode_bundle_file(Path.join(extract_dir, "meta")),
         {:ok, data} <- read_and_decode_bundle_file(Path.join(extract_dir, "data")) do
      _ = File.rm_rf(extract_dir)
      {:ok, %{meta: meta, data: data_conversions(data, opts)}}
    else
      {:error, %ExtractError{}} = error ->
        _ = File.rm_rf(extract_dir)
        error

      {:error, {file, reason}} ->
        _ = File.rm_rf(extract_dir)
        {:error, ExtractError.exception({"Extracting file: #{file}", reason})}

      {:error, reason} ->
        _ = File.rm_rf(extract_dir)
        {:error, ExtractError.exception({"Extracting into #{extract_dir}", reason})}
    end
  end

  defp read_and_decode_bundle_file(file) do
    case File.read(file) do
      {:ok, contents} ->
        {:ok, :erlang.binary_to_term(contents)}

      {:error, reason} ->
        {:error, ExtractError.exception({"decoding file: #{file}", reason})}
    end
  end

  defp get_rootname(bundle_file) do
    file_base = Path.basename(bundle_file)

    if String.contains?(file_base, ".tar.gz") do
      Path.rootname(file_base, ".tar.gz")
    else
      Path.rootname(file_base, ".tar")
    end
  end

  defp data_conversions(data, opts) do
    Enum.map(data, fn d -> run_conversions(d, opts) end)
  end

  defp run_conversions(data_entry, []) do
    data_entry
  end

  defp run_conversions({timestamp, data}, [{:time_as, NaiveDateTime} | rest]) do
    new_ts = timestamp |> DateTime.from_unix!() |> DateTime.to_naive()
    run_conversions({new_ts, data}, rest)
  end

  defp run_conversions({timestamp, data}, [{:time_as, DateTime} | rest]) do
    new_ts = timestamp |> DateTime.from_unix!()
    run_conversions({new_ts, data}, rest)
  end

  defp run_conversions(entry, [_item | rest]) do
    run_conversions(entry, rest)
  end
end
